/**
 * DevKraken 3DS SDK v1.0.0 - Production CDN Build
 * (c) 2025 DevKraken <soman@devkraken.com>
 * @license MIT
 */
!function (e, t) { "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define("GPayments3DS", t) : (e = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : e).GPayments3DS = t() }(this, function () {
    "use strict";

    // Feature detection and polyfills
    const hasPromise = typeof Promise !== "undefined"; const hasFetch = typeof fetch !== "undefined";

    // Promise polyfill for older browsers
    if (!hasPromise) { window.Promise = function (e) { const t = this; t.state = "pending"; t.value = undefined; t.handlers = []; function n(e) { if (t.state === "pending") { t.state = "fulfilled"; t.value = e; t.handlers.forEach(r); t.handlers = null } } function o(e) { if (t.state === "pending") { t.state = "rejected"; t.value = e; t.handlers.forEach(r); t.handlers = null } } function r(e) { if (t.state === "pending") { t.handlers.push(e) } else { if (t.state === "fulfilled" && typeof e.onFulfilled === "function") { e.onFulfilled(t.value) } if (t.state === "rejected" && typeof e.onRejected === "function") { e.onRejected(t.value) } } } t.then = function (e, t) { return new Promise(function (n, o) { r({ onFulfilled: function (t) { try { n(e ? e(t) : t) } catch (e) { o(e) } }, onRejected: function (e) { try { n(t ? t(e) : e) } catch (e) { o(e) } } }) }) }; try { e(n, o) } catch (e) { o(e) } } }

    // Fetch polyfill for older browsers
    if (!hasFetch) { window.fetch = function (e, t) { return new Promise(function (n, o) { const r = new XMLHttpRequest; const s = t && t.method || "GET"; const a = t && t.headers || {}; const i = t && t.body; r.open(s, e, true); Object.keys(a).forEach(function (e) { r.setRequestHeader(e, a[e]) }); r.onload = function () { const e = { ok: r.status >= 200 && r.status < 300, status: r.status, statusText: r.statusText, json: function () { return Promise.resolve(JSON.parse(r.responseText)) }, text: function () { return Promise.resolve(r.responseText) } }; n(e) }; r.onerror = function () { o(new Error("Network error")) }; r.ontimeout = function () { o(new Error("Request timeout")) }; r.timeout = 3e4; r.send(i) }) } }

    // Card Validator - Optimized for performance
    class CardValidator { constructor() { this.patterns = { cardNumber: /^\d{13,19}$/, expiryDate: /^\d{2}\/\d{2}$/, numericOnly: /^\d+$/, nonDigits: /\D/g } } validateCardNumber(e) { if (!e || e.length < 13) return false; const t = e.replace(this.patterns.nonDigits, ""); if (!this.patterns.cardNumber.test(t)) return false; return this.luhnCheck(t) } luhnCheck(e) { let t = 0; let n = false; for (let o = e.length - 1; o >= 0; o--) { let r = parseInt(e[o], 10); if (n) { r *= 2; if (r > 9) r -= 9 } t += r; n = !n } return t % 10 === 0 } validateExpiryDate(e) { if (!e || !this.patterns.expiryDate.test(e)) return false; const t = e.split("/"); const n = parseInt(t[0], 10); const o = parseInt("20" + t[1], 10); if (n < 1 || n > 12) return false; const r = new Date; const s = r.getMonth() + 1; const a = r.getFullYear(); return !(o < a || o === a && n < s) } formatExpiryDate(e) { const t = e.split("/"); return t.length === 2 ? t[1].trim() + t[0].trim() : "" } getCardType(e) { const t = e.replace(this.patterns.nonDigits, ""); if (!t) return null; if (/^4/.test(t)) return "visa"; if (/^5[1-5]|^2[2-7]/.test(t)) return "mastercard"; if (/^3[47]/.test(t)) return "amex"; if (/^6(?:011|5)/.test(t)) return "discover"; if (/^35/.test(t)) return "jcb"; if (/^3[068]/.test(t)) return "diners"; return null } maskCardNumber(e) { const t = e.replace(this.patterns.nonDigits, ""); if (t.length <= 6) return "*".repeat(t.length); return t.substring(0, 6) + "*".repeat(t.length - 10) + t.substring(t.length - 4) } }

    // Browser Collector - Enhanced fingerprinting
    class BrowserCollector { constructor() { this.cache = null; this.cacheTime = 0; this.cacheDuration = 6e4 } collectAndEncode() { const e = Date.now(); if (this.cache && e - this.cacheTime < this.cacheDuration) { return this.cache } const t = this.collectBrowserInfo(); this.cache = btoa(JSON.stringify(t)); this.cacheTime = e; return this.cache } collectBrowserInfo() { const e = navigator; const t = window.screen; const n = new Date; return { browserUserAgent: e.userAgent || "", browserLanguage: e.language || e.browserLanguage || "", browserScreenWidth: (t.width || 0).toString(), browserScreenHeight: (t.height || 0).toString(), browserColorDepth: (t.colorDepth || 24).toString(), browserTZ: n.getTimezoneOffset().toString(), browserAcceptHeader: "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8", browserJavaEnabled: this.isJavaEnabled(), browserJavascriptEnabled: true, browserIP: "", platform: e.platform || "", cookieEnabled: e.cookieEnabled || false, doNotTrack: e.doNotTrack || "", hardwareConcurrency: e.hardwareConcurrency || 0, maxTouchPoints: e.maxTouchPoints || 0, deviceMemory: e.deviceMemory || 0, connection: this.getConnectionInfo(), timezone: Intl.DateTimeFormat().resolvedOptions().timeZone || "", canvasFingerprint: this.getCanvasFingerprint(), webglFingerprint: this.getWebGLFingerprint() } } isJavaEnabled() { try { return navigator.javaEnabled && navigator.javaEnabled() } catch (e) { return false } } getConnectionInfo() { const e = navigator.connection || navigator.mozConnection || navigator.webkitConnection; if (!e) return {}; return { effectiveType: e.effectiveType || "", downlink: e.downlink || 0, rtt: e.rtt || 0 } } getCanvasFingerprint() { try { const e = document.createElement("canvas"); const t = e.getContext("2d"); t.textBaseline = "top"; t.font = "14px Arial"; t.fillText("DevKraken 3DS Fingerprint", 2, 2); t.fillStyle = "rgba(102, 204, 0, 0.7)"; t.fillRect(100, 5, 80, 20); return e.toDataURL().slice(-50) } catch (e) { return "" } } getWebGLFingerprint() { try { const e = document.createElement("canvas"); const t = e.getContext("webgl") || e.getContext("experimental-webgl"); if (!t) return ""; const n = t.getExtension("WEBGL_debug_renderer_info"); if (n) { return (t.getParameter(n.UNMASKED_VENDOR_WEBGL) + "~" + t.getParameter(n.UNMASKED_RENDERER_WEBGL)).slice(0, 100) } return "" } catch (e) { return "" } } }

    // Iframe Manager - Fixed for 3DS
    class IframeManager { constructor(e) { this.containerId = e; this.iframes = new Map } createIframe(e, t) { try { this.removeIframe(e); const n = document.createElement("iframe"); n.id = e; n.src = t; n.setAttribute("sandbox", "allow-scripts allow-same-origin allow-forms"); n.setAttribute("loading", "eager"); n.setAttribute("importance", "high"); n.style.cssText = "width:0px;height:0px;border:none;position:absolute;top:-9999px;left:-9999px;visibility:hidden;opacity:0"; const o = document.getElementById(this.containerId) || document.body; o.appendChild(n); this.iframes.set(e, { element: n, created: Date.now(), src: t }); console.log(`[DevKraken3DS] Created iframe: ${e} -> ${t}`); return n } catch (e) { console.error("[DevKraken3DS] Failed to create iframe:", e); return null } } removeIframe(e) { const t = this.iframes.get(e); if (t) { const e = t.element; if (e.parentNode) { e.parentNode.removeChild(e) } this.iframes.delete(e); console.log(`[DevKraken3DS] Removed iframe: ${e}`) } } cleanup() { console.log(`[DevKraken3DS] Cleaning up ${this.iframes.size} iframes`); this.iframes.forEach((e, t) => { const n = e.element; if (n.parentNode) { n.parentNode.removeChild(n) } }); this.iframes.clear() } getIframeCount() { return this.iframes.size } }

    // Challenge Handler - Fixed for iframe stability
    class ChallengeHandler { constructor(e) { this.containerId = e; this.challengeIframe = null; this.isVisible = false } showChallenge(e) { try { console.log("[DevKraken3DS] Showing challenge:", e); const t = document.getElementById(this.containerId); if (!t) { console.error("[DevKraken3DS] Challenge container not found:", this.containerId); return false } t.innerHTML = ""; this.challengeIframe = document.createElement("iframe"); this.challengeIframe.src = e; this.challengeIframe.setAttribute("sandbox", "allow-scripts allow-same-origin allow-forms allow-top-navigation"); this.challengeIframe.setAttribute("allow", "payment"); this.challengeIframe.style.cssText = "width:100%;height:400px;border:1px solid #ddd;border-radius:4px;background-color:#fff;"; t.appendChild(this.challengeIframe); this.isVisible = true; console.log("[DevKraken3DS] Challenge iframe created and displayed"); return true } catch (e) { console.error("[DevKraken3DS] Failed to show challenge:", e); return false } } hide() { if (this.challengeIframe) { this.challengeIframe.remove(); this.challengeIframe = null } this.isVisible = false; const e = document.getElementById(this.containerId); if (e) { e.innerHTML = "" } console.log("[DevKraken3DS] Challenge hidden") } isDisplayed() { return this.isVisible } }

    // Main 3DS SDK Class - Production optimized
    class GPayments3DS { constructor(e = {}) { if (!e.apiEndpoint) { throw new Error("apiEndpoint is required") } this.options = { apiEndpoint: e.apiEndpoint, onSuccess: e.onSuccess || (() => { }), onError: e.onError || (() => { }), onChallenge: e.onChallenge || (() => { }), challengeContainer: e.challengeContainer || "challenge-container", iframeContainer: e.iframeContainer || "iframe-container", debug: e.debug || false, timeout: e.timeout || 3e4, retries: e.retries || 3, ...e }; this.transactionData = this.createInitialState(); this.requestId = this.generateRequestId(); this.cardValidator = new CardValidator; this.browserCollector = new BrowserCollector; this.iframeManager = new IframeManager(this.options.iframeContainer); this.challengeHandler = new ChallengeHandler(this.options.challengeContainer); this.handleFrameEvent = this.handleFrameEvent.bind(this); this.handleVisibilityChange = this.handleVisibilityChange.bind(this); this.handleBeforeUnload = this.handleBeforeUnload.bind(this); this.setupEventListeners(); this.performanceMetrics = { startTime: performance.now(), apiCalls: 0, errors: 0, memoryUsage: [] }; this.log("DevKraken 3DS SDK initialized", { version: "1.0.0", requestId: this.requestId, options: this.sanitizeOptions(this.options) }) } createInitialState() { return { threeDSServerTransID: null, threeDSRequestorTransID: null, threeDSServerCallbackUrl: null, monUrl: null, resultMonUrl: null, authUrl: null, browserInfo: null, eventReceived: false, challengeCompleted: false, cardNumber: null, amount: null, additionalData: null, state: "initialized" } } setupEventListeners() { window.addEventListener("message", this.handleFrameEvent, false); document.addEventListener("visibilitychange", this.handleVisibilityChange, false); window.addEventListener("beforeunload", this.handleBeforeUnload, false); window.addEventListener("focus", () => this.handleFocusChange(true), false); window.addEventListener("blur", () => this.handleFocusChange(false), false) } removeEventListeners() { window.removeEventListener("message", this.handleFrameEvent, false); document.removeEventListener("visibilitychange", this.handleVisibilityChange, false); window.removeEventListener("beforeunload", this.handleBeforeUnload, false); window.removeEventListener("focus", this.handleFocusChange, false); window.removeEventListener("blur", this.handleFocusChange, false) } handleVisibilityChange() { if (document.hidden) { this.log("Page hidden - pausing operations") } else { this.log("Page visible - resuming operations") } } handleFocusChange(e) { this.log(e ? "Page focused" : "Page blurred") } handleBeforeUnload() { this.destroy() } async authenticate(e, t = {}) { try { this.transactionData.state = "authenticating"; this.recordMetric("authenticate_start"); this.log("Starting 3DS authentication", { requestId: this.requestId, cardMask: this.cardValidator.maskCardNumber(e.cardNumber || ""), amount: e.amount }); await this.validateInputs(e); await this.initialize3DS(e.cardNumber.replace(/\s/g, ""), e.amount, { ...t, expiryDate: e.expiryDate }); this.recordMetric("authenticate_success"); return true } catch (e) { this.recordMetric("authenticate_error"); this.transactionData.state = "error"; this.log("Authentication error:", e); this.options.onError(e.message || "Authentication failed"); throw e } } async validateInputs(e) { const t = []; if (!this.cardValidator.validateCardNumber(e.cardNumber)) { t.push("Please enter a valid card number") } if (e.expiryDate && !this.cardValidator.validateExpiryDate(e.expiryDate)) { t.push("Please enter a valid expiry date (MM/YY) that has not expired") } if (!e.amount || isNaN(parseFloat(e.amount)) || parseFloat(e.amount) <= 0) { t.push("Please enter a valid amount") } if (t.length > 0) { throw new Error(t.join(". ")) } } async initialize3DS(e, t, n = {}) { try { this.transactionData.threeDSRequestorTransID = this.generateUUID(); this.transactionData.cardNumber = e; this.transactionData.amount = t; this.transactionData.additionalData = n; this.transactionData.state = "initializing"; const o = { operation: "init", cardNumber: e, requestId: this.requestId, ...n }; this.log("Sending init request", { requestId: this.requestId }); const r = await this.makeApiCall(o); if (!r.data.threeDSServerTransID || !r.data.iframeUrls?.callback) { throw new Error("Invalid response: missing required fields") } Object.assign(this.transactionData, { threeDSServerTransID: r.data.threeDSServerTransID, threeDSRequestorTransID: r.data.threeDSRequestorTransID, threeDSServerCallbackUrl: r.data.iframeUrls.callback, monUrl: r.data.iframeUrls.monitor, authUrl: r.data.authUrl, state: "initialized" }); this.setupMonitoringIframes(); this.setBrowserInfoTimeout(); return true } catch (e) { this.transactionData.state = "init_error"; this.log("Initialization error:", e); throw e } } setupMonitoringIframes() { if (this.transactionData.monUrl) { this.iframeManager.createIframe("monitoringIframe", this.transactionData.monUrl) } if (this.transactionData.threeDSServerCallbackUrl) { this.iframeManager.createIframe("callbackIframe", this.transactionData.threeDSServerCallbackUrl) } } setBrowserInfoTimeout() { this.browserInfoTimeout = setTimeout(() => { if (!this.transactionData.eventReceived && this.transactionData.state === "initialized") { this.log("Browser info timeout - proceeding with fallback"); this.processAuthentication(this.transactionData.cardNumber, this.transactionData.amount, this.transactionData.additionalData) } }, 6e3) } async processAuthentication(e, t, n = {}) { try { this.transactionData.state = "processing_auth"; if (!this.transactionData.browserInfo) { this.log("Creating fallback browser info"); this.transactionData.browserInfo = this.browserCollector.collectAndEncode() } const o = n.expiryDate ? this.cardValidator.formatExpiryDate(n.expiryDate) : null; const r = { operation: "auth", acctNumber: e, cardNumber: e, browserInfo: this.transactionData.browserInfo, cardExpiryDate: o, purchaseAmount: this.formatAmount(t), threeDSServerTransID: this.transactionData.threeDSServerTransID, threeDSRequestorTransID: this.transactionData.threeDSRequestorTransID, authUrl: this.transactionData.authUrl, requestId: this.requestId, ...n }; this.log("Sending auth request", { requestId: this.requestId }); const s = await this.makeApiCall(r); if (s.resultMonUrl) { this.transactionData.resultMonUrl = s.resultMonUrl; this.iframeManager.createIframe("resultMonitoringIframe", s.resultMonUrl) } this.handleAuthResponse(s.data || s); return true } catch (e) { this.transactionData.state = "auth_error"; this.log("Authentication processing error:", e); throw e } } handleAuthResponse(e) { const t = e.transStatus; this.transactionData.state = `auth_${t}`; this.log("Auth response received", { transStatus: t, requestId: this.requestId }); const n = { C: () => this.handleChallenge(e), D: () => this.handleDecoupled(e), Y: () => this.handleSuccess(e, "success", "Payment Authenticated Successfully"), N: () => this.handleError(e, "failed", "Authentication Failed - Not Authenticated"), U: () => this.handleError(e, "error", "Authentication Error - Technical Issue"), A: () => this.handleSuccess(e, "partial", "Authentication Attempted but Not Verified"), R: () => this.handleError(e, "rejected", "Authentication Rejected by Issuer") }; const o = n[t]; if (o) { o() } else { this.handleSuccess(e, "complete", "Authentication Completed") } } handleChallenge(e) { if (e.challengeUrl) { this.log("Challenge required"); this.challengeHandler.showChallenge(e.challengeUrl, { showOverlay: true, iframeStyles: this.options.challengeStyles }); this.options.onChallenge(e) } else { this.handleError(e, "error", "Challenge required but no challenge URL provided") } } handleDecoupled(e) { this.options.onSuccess({ status: "decoupled", message: "Decoupled Authentication Required - Please verify on your device", transStatus: "D", details: e, requestId: this.requestId }) } handleSuccess(e, t, n) { this.options.onSuccess({ status: t, message: n, transStatus: e.transStatus, details: e, requestId: this.requestId }) } handleError(e, t, n) { this.options.onError({ status: t, message: n, transStatus: e.transStatus, details: e, requestId: this.requestId }) } async handleFrameEvent(e) { try { this.log("Frame event received", { origin: e.origin, data: typeof e.data === "object" ? e.data.event : e.data }); if (typeof e.data === "object" && e.data.event) { await this.processObjectEvent(e.data) } else if (e.data?.type === "3ds-notification") { await this.processNotificationEvent(e.data) } else if (typeof e.data === "string") { await this.processStringEvent(e.data) } } catch (e) { this.log("Error handling frame event:", e); this.options.onError("Error processing 3DS response: " + e.message) } } async processObjectEvent(e) { const t = e.event; if (e.param) { this.transactionData.browserInfo = e.param; this.log("Browser info received from 3DS Server") } if (["3DSMethodSkipped", "3DSMethodFinished"].includes(t)) { this.transactionData.eventReceived = true; if (this.browserInfoTimeout) { clearTimeout(this.browserInfoTimeout) } if (this.transactionData.browserInfo) { await this.processAuthentication(this.transactionData.cardNumber, this.transactionData.amount, this.transactionData.additionalData) } else { this.options.onError("Authentication failed: No browser info received from 3DS server") } } else if (t === "InitAuthTimedOut") { this.transactionData.eventReceived = true; await this.processAuthentication(this.transactionData.cardNumber, this.transactionData.amount, this.transactionData.additionalData) } else if (["Challenge:Completed", "AuthResultReady"].includes(t)) { if (!this.transactionData.challengeCompleted) { this.transactionData.challengeCompleted = true; await this.updateChallengeStatusAndGetResult() } } } async processNotificationEvent(e) { if (e.event === "AuthResultReady" && !this.transactionData.challengeCompleted) { this.transactionData.challengeCompleted = true; await this.updateChallengeStatusAndGetResult() } else if (["3DSMethodSkipped", "3DSMethodFinished"].includes(e.event)) { this.transactionData.eventReceived = true; if (e.param) { this.transactionData.browserInfo = e.param } await this.processAuthentication(this.transactionData.cardNumber, this.transactionData.amount, this.transactionData.additionalData) } } async processStringEvent(e) { if (["3DSMethodSkipped", "3DSMethodFinished"].includes(e)) { this.transactionData.eventReceived = true; await this.processAuthentication(this.transactionData.cardNumber, this.transactionData.amount, this.transactionData.additionalData) } else if (["Challenge:Completed", "AuthResultReady"].includes(e)) { if (!this.transactionData.challengeCompleted) { this.transactionData.challengeCompleted = true; await this.updateChallengeStatusAndGetResult() } } } async updateChallengeStatusAndGetResult() { try { if (!this.transactionData.threeDSServerTransID) { throw new Error("Missing transaction ID") } this.transactionData.state = "updating_challenge"; await this.makeApiCall({ operation: "updateChallengeStatus", threeDSServerTransID: this.transactionData.threeDSServerTransID, status: "01", requestId: this.requestId }); await this.getAuthenticationResult(); return true } catch (e) { this.log("Error updating challenge status:", e); this.options.onError("Error updating challenge status: " + e.message); return false } } async getAuthenticationResult() { try { if (!this.transactionData.threeDSServerTransID) { throw new Error("Missing transaction ID") } this.transactionData.state = "getting_result"; const e = new URL(this.options.apiEndpoint, window.location.origin); e.searchParams.set("operation", "getAuthResult"); e.searchParams.set("threeDSServerTransID", this.transactionData.threeDSServerTransID); e.searchParams.set("requestId", this.requestId); this.log("Getting auth result", { requestId: this.requestId }); const t = await fetch(e, { method: "GET", headers: { "Content-Type": "application/json", "X-Request-ID": this.requestId } }); if (!t.ok) { throw new Error(`HTTP ${t.status}: ${t.statusText}`) } const n = await t.json(); if (n.error) { throw new Error(n.error) } this.cleanup(); const o = n.data || n; const r = o.transStatus || "Unknown"; this.transactionData.state = "completed"; this.options.onSuccess({ status: o.status || "completed", message: o.message || "Authentication Completed", transStatus: r, details: o, requestId: this.requestId }); return true } catch (e) { this.transactionData.state = "result_error"; this.log("Get auth result error:", e); this.options.onError("Error getting authentication result: " + e.message); return false } } async makeApiCall(e, t = 0) { try { this.performanceMetrics.apiCalls++; const n = performance.now(); const o = await fetch(this.options.apiEndpoint, { method: "POST", headers: { "Content-Type": "application/json", "X-Request-ID": this.requestId, "X-SDK-Version": "1.0.0" }, body: JSON.stringify(e) }); const r = performance.now() - n; this.log(`API call completed in ${r.toFixed(2)}ms`, { operation: e.operation }); if (!o.ok) { throw new Error(`HTTP ${o.status}: ${o.statusText}`) } const s = await o.json(); if (s.error) { throw new Error(s.error) } return s } catch (n) { this.performanceMetrics.errors++; if (t < this.options.retries && this.isRetryableError(n)) { this.log(`Retrying API call (${t + 1}/${this.options.retries})`, { error: n.message }); await this.delay(Math.pow(2, t) * 1e3); return this.makeApiCall(e, t + 1) } throw n } } isRetryableError(e) { const t = ["Network error", "Request timeout", "HTTP 502", "HTTP 503", "HTTP 504"]; return t.some(t => e.message.includes(t)) } delay(e) { return new Promise(t => setTimeout(t, e)) } cleanup() { this.iframeManager.cleanup(); this.challengeHandler.hide(); if (this.browserInfoTimeout) { clearTimeout(this.browserInfoTimeout); this.browserInfoTimeout = null } } destroy() { this.log("Destroying SDK instance"); this.cleanup(); this.removeEventListeners(); this.transactionData = this.createInitialState(); this.performanceMetrics = null; if (typeof window.gc === "function") { window.gc() } } generateUUID() { return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (e) { const t = Math.random() * 16 | 0; const n = e === "x" ? t : t & 3 | 8; return n.toString(16) }) } generateRequestId() { return "req_" + Date.now() + "_" + Math.random().toString(36).substr(2, 9) } formatAmount(e) { return Math.round(parseFloat(e) * 100).toString() } sanitizeOptions(e) { const t = { ...e }; delete t.onSuccess; delete t.onError; delete t.onChallenge; return t } recordMetric(e) { if (this.performanceMetrics) { this.performanceMetrics[e] = performance.now(); if (performance.memory) { this.performanceMetrics.memoryUsage.push({ timestamp: Date.now(), used: performance.memory.usedJSHeapSize, total: performance.memory.totalJSHeapSize }) } } } getPerformanceMetrics() { return { ...this.performanceMetrics, transactionState: this.transactionData.state, iframeCount: this.iframeManager.getIframeCount(), challengeVisible: this.challengeHandler.isDisplayed(), requestId: this.requestId, uptime: performance.now() - this.performanceMetrics.startTime } } log(...e) { if (this.options.debug) { console.log(`[DevKraken3DS:${this.requestId}]`, ...e) } } static debounce(e, t) { let n; return function (...o) { const r = () => { clearTimeout(n); e(...o) }; clearTimeout(n); n = setTimeout(r, t) } } static throttle(e, t) { let n; return function () { const o = arguments; const r = this; if (!n) { e.apply(r, o); n = true; setTimeout(() => n = false, t) } } } static get version() { return "1.0.0" } static get author() { return "DevKraken <soman@devkraken.com>" } }

    return GPayments3DS;

});